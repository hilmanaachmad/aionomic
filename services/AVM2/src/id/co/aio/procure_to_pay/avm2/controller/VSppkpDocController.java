/*Copyright (c) 2020-2021 aio.co.id All Rights Reserved.
 This software is the confidential and proprietary information of aio.co.id You shall not disclose such Confidential Information and shall use it only in accordance
 with the terms of the source code license agreement you entered into with aio.co.id*/
package id.co.aio.procure_to_pay.avm2.controller;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/

import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.wavemaker.commons.wrapper.StringWrapper;
import com.wavemaker.runtime.data.export.DataExportOptions;
import com.wavemaker.runtime.data.export.ExportType;
import com.wavemaker.runtime.data.expression.QueryFilter;
import com.wavemaker.runtime.data.model.AggregationInfo;
import com.wavemaker.runtime.file.manager.ExportedFileManager;
import com.wavemaker.runtime.file.model.Downloadable;
import com.wavemaker.tools.api.core.annotations.MapTo;
import com.wavemaker.tools.api.core.annotations.WMAccessVisibility;
import com.wavemaker.tools.api.core.models.AccessSpecifier;
import com.wordnik.swagger.annotations.Api;
import com.wordnik.swagger.annotations.ApiOperation;
import com.wordnik.swagger.annotations.ApiParam;

import id.co.aio.procure_to_pay.avm2.VSppkpDoc;
import id.co.aio.procure_to_pay.avm2.service.VSppkpDocService;


/**
 * Controller object for domain model class VSppkpDoc.
 * @see VSppkpDoc
 */
@RestController("AVM2.VSppkpDocController")
@Api(value = "VSppkpDocController", description = "Exposes APIs to work with VSppkpDoc resource.")
@RequestMapping("/AVM2/VSppkpDoc")
public class VSppkpDocController {

    private static final Logger LOGGER = LoggerFactory.getLogger(VSppkpDocController.class);

    @Autowired
	@Qualifier("AVM2.VSppkpDocService")
	private VSppkpDocService vSppkpDocService;

	@Autowired
	private ExportedFileManager exportedFileManager;

	@ApiOperation(value = "Creates a new VSppkpDoc instance.")
    @RequestMapping(method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public VSppkpDoc createVSppkpDoc(@RequestBody VSppkpDoc vsppkpDoc) {
		LOGGER.debug("Create VSppkpDoc with information: {}" , vsppkpDoc);

		vsppkpDoc = vSppkpDocService.create(vsppkpDoc);
		LOGGER.debug("Created VSppkpDoc with information: {}" , vsppkpDoc);

	    return vsppkpDoc;
	}

    @ApiOperation(value = "Returns the VSppkpDoc instance associated with the given id.")
    @RequestMapping(value = "/{abIdnt:.+}", method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public VSppkpDoc getVSppkpDoc(@PathVariable("abIdnt") Integer abIdnt) {
        LOGGER.debug("Getting VSppkpDoc with id: {}" , abIdnt);

        VSppkpDoc foundVSppkpDoc = vSppkpDocService.getById(abIdnt);
        LOGGER.debug("VSppkpDoc details with id: {}" , foundVSppkpDoc);

        return foundVSppkpDoc;
    }

    @ApiOperation(value = "Updates the VSppkpDoc instance associated with the given id.")
    @RequestMapping(value = "/{abIdnt:.+}", method = RequestMethod.PUT)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public VSppkpDoc editVSppkpDoc(@PathVariable("abIdnt") Integer abIdnt, @RequestBody VSppkpDoc vsppkpDoc) {
        LOGGER.debug("Editing VSppkpDoc with id: {}" , vsppkpDoc.getAbIdnt());

        vsppkpDoc.setAbIdnt(abIdnt);
        vsppkpDoc = vSppkpDocService.update(vsppkpDoc);
        LOGGER.debug("VSppkpDoc details with id: {}" , vsppkpDoc);

        return vsppkpDoc;
    }
    
    @ApiOperation(value = "Partially updates the VSppkpDoc instance associated with the given id.")
    @RequestMapping(value = "/{abIdnt:.+}", method = RequestMethod.PATCH)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public VSppkpDoc patchVSppkpDoc(@PathVariable("abIdnt") Integer abIdnt, @RequestBody @MapTo(VSppkpDoc.class) Map<String, Object> vsppkpDocPatch) {
        LOGGER.debug("Partially updating VSppkpDoc with id: {}" , abIdnt);

        VSppkpDoc vsppkpDoc = vSppkpDocService.partialUpdate(abIdnt, vsppkpDocPatch);
        LOGGER.debug("VSppkpDoc details after partial update: {}" , vsppkpDoc);

        return vsppkpDoc;
    }

    @ApiOperation(value = "Deletes the VSppkpDoc instance associated with the given id.")
    @RequestMapping(value = "/{abIdnt:.+}", method = RequestMethod.DELETE)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public boolean deleteVSppkpDoc(@PathVariable("abIdnt") Integer abIdnt) {
        LOGGER.debug("Deleting VSppkpDoc with id: {}" , abIdnt);

        VSppkpDoc deletedVSppkpDoc = vSppkpDocService.delete(abIdnt);

        return deletedVSppkpDoc != null;
    }

    /**
     * @deprecated Use {@link #findVSppkpDocs(String, Pageable)} instead.
     */
    @Deprecated
    @ApiOperation(value = "Returns the list of VSppkpDoc instances matching the search criteria.")
    @RequestMapping(value = "/search", method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<VSppkpDoc> searchVSppkpDocsByQueryFilters( Pageable pageable, @RequestBody QueryFilter[] queryFilters) {
        LOGGER.debug("Rendering VSppkpDocs list by query filter:{}", (Object) queryFilters);
        return vSppkpDocService.findAll(queryFilters, pageable);
    }

    @ApiOperation(value = "Returns the paginated list of VSppkpDoc instances matching the optional query (q) request param. If there is no query provided, it returns all the instances. Pagination & Sorting parameters such as page& size, sort can be sent as request parameters. The sort value should be a comma separated list of field names & optional sort order to sort the data on. eg: field1 asc, field2 desc etc ")
    @RequestMapping(method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<VSppkpDoc> findVSppkpDocs(@ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
        LOGGER.debug("Rendering VSppkpDocs list by filter:", query);
        return vSppkpDocService.findAll(query, pageable);
    }

    @ApiOperation(value = "Returns the paginated list of VSppkpDoc instances matching the optional query (q) request param. This API should be used only if the query string is too big to fit in GET request with request param. The request has to made in application/x-www-form-urlencoded format.")
    @RequestMapping(value="/filter", method = RequestMethod.POST, consumes= "application/x-www-form-urlencoded")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<VSppkpDoc> filterVSppkpDocs(@ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
        LOGGER.debug("Rendering VSppkpDocs list by filter", query);
        return vSppkpDocService.findAll(query, pageable);
    }

    @ApiOperation(value = "Returns downloadable file for the data matching the optional query (q) request param.")
    @RequestMapping(value = "/export/{exportType}", method = RequestMethod.GET, produces = "application/octet-stream")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Downloadable exportVSppkpDocs(@PathVariable("exportType") ExportType exportType, @ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
         return vSppkpDocService.export(exportType, query, pageable);
    }

    @ApiOperation(value = "Returns a URL to download a file for the data matching the optional query (q) request param and the required fields provided in the Export Options.") 
    @RequestMapping(value = "/export", method = {RequestMethod.POST}, consumes = "application/json")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public StringWrapper exportVSppkpDocsAndGetURL(@RequestBody DataExportOptions exportOptions, Pageable pageable) {
        String exportedFileName = exportOptions.getFileName();
        if(exportedFileName == null || exportedFileName.isEmpty()) {
            exportedFileName = VSppkpDoc.class.getSimpleName();
        }
        exportedFileName += exportOptions.getExportType().getExtension();
        String exportedUrl = exportedFileManager.registerAndGetURL(exportedFileName, outputStream -> vSppkpDocService.export(exportOptions, pageable, outputStream));
        return new StringWrapper(exportedUrl);
    }

	@ApiOperation(value = "Returns the total count of VSppkpDoc instances matching the optional query (q) request param.")
	@RequestMapping(value = "/count", method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
	public Long countVSppkpDocs( @ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query) {
		LOGGER.debug("counting VSppkpDocs");
		return vSppkpDocService.count(query);
	}

    @ApiOperation(value = "Returns aggregated result with given aggregation info")
	@RequestMapping(value = "/aggregations", method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
	public Page<Map<String, Object>> getVSppkpDocAggregatedValues(@RequestBody AggregationInfo aggregationInfo, Pageable pageable) {
        LOGGER.debug("Fetching aggregated results for {}", aggregationInfo);
        return vSppkpDocService.getAggregatedValues(aggregationInfo, pageable);
    }


    /**
	 * This setter method should only be used by unit tests
	 *
	 * @param service VSppkpDocService instance
	 */
	protected void setVSppkpDocService(VSppkpDocService service) {
		this.vSppkpDocService = service;
	}

}